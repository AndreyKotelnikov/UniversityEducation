/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
							Указатели.
*************************************************************/
#define _USE_MATH_DEFINES
#include <cmath>
#include <iostream>
#include <tchar.h>
namespace Lab200000
{
	int nref = 1;
	int& ref = nref;
}



#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку
int _tmain()
{
	// ********************************************************
	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
	//1.1
	/*{
	int y;*///Задайте значение y, например, с помощью потока ввода

	//С помощью побитовых операторов и операторов сдвига выведите значение "y"
	//на консоль в двоичном виде, например:
	//если y==9, то
	// а) 0 0 0 0 ...   0 0 1 0 0 1 (всего 32 двоичных цифры)
	setlocale(LC_ALL, "Russian");
	//std::cout << "Введите y :" << std::endl;
	//std::cout << std::endl;
	//std::cin >> y;
	//std::cout << std::endl;
	//for (int i = 31; i >= 0; i--)
	//{
	//	std::cout << ((y>>i)&1) << " ";
	//};
	//std::cout << std::endl;

	//// б) пропустите незначащие нули -  1 0 0 1
	//char f = 0;
	//std::cout << std::endl;
	//std::cout << "А теперь без незначащих нулей :" << std::endl;
	//std::cout << std::endl;
	//
	//for (int i = 31; i >= 0; i--)
	//{
	//	if ((((y >> i) & 1) == 0) && (f == 0)) { continue; }
	//	else
	//	{
	//		std::cout << ((y >> i) & 1) << " "; f = 1;
	//	}
	//	
	//}
	//std::cout << std::endl;
	//std::cin >> y;
	//std::cout << std::endl;
	//}
	//

	////1.2 Дана целая переменная
	//{
	//	int y;//Задайте значение y, например, с помощью потока ввода

	//	//"Сдвиньте" все единицы в сформированном значении вправо, например:
	//	//было:   0100 1111 0000 0000 0110 1111 0000 0010
	//	//стало:  0000 0000 0000 0000 0000 1111 1111 1111
	//	//Реализовать задачу посредством одного цикла!
	//	std::cout << "Введите y :" << std::endl;
	//	std::cout << std::endl;
	//	std::cin >> y;
	//	std::cout << std::endl;
	//	std::cout << "Было :" << std::endl;
	//	std::cout << std::endl;
	//	int s = 0, t = 0;
	//	for (int i = 31; i >= 0; i--)
	//	{
	//		std::cout << ((y >> i) & 1) << " ";
	//		if (((y >> i) & 1) == 1) { s = s + (1 << t); t++; }
	//	};
	//	std::cout << std::endl;
	//	std::cout << std::endl;
	//	
	//	std::cout << "Стало :" << std::endl;
	//	std::cout << std::endl;
	//	

	//	for (int i = 31; i >= 0; i--)
	//	{
	//		std::cout << ((s >> i) & 1) << " ";
	//	}
	//	std::cout << std::endl;
	//	std::cin >> y;
	//	std::cout << std::endl;

	//}


	//1.3 Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{
		short sNum = 0x8008;
		short sRes = 0;

		sRes = ~sNum; //0x7ff7

		sRes = sNum | 0x0ff0; //0x8ff8

		sRes = sNum & 0x000f; //0x0008

		sRes = sNum ^ 0xff00; //0x7f08

		sRes = sNum >> 3; //0xf001

		sRes = sNum << 1; //0x0010

	}

	stop
		// ********************************************************
		//Задание 2. Директивы препроцессора

		//2.1. Использование "математических" макросов стандартной библиотеки:
		//в заголовочном файле <cmath> (который в свою очередь включает старый
		//файл math.h) определены часто используемые математические
		//константы, например M_PI. Воспользуйтесь этой константой для
		//вычисления длины окружности.
		//Обратите внимание: определения констант в свою очередь тоже заключены
		//в директивы условной трансляции. Что еще, кроме подключения заголовочного
		//файла, требуется сделать???
		double c, r;
	c = 2 * M_PI*r;


	//2.2.Макросы с параметрами.
	//2.2.1 Напишите свою макроподстановку LENGTH которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	{
#define LENGTH(a) (2*M_PI*(a))
		float l1 = LENGTH(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGTH(2); // должно быть 0.07957...
		stop
	}








	//2.2.2 определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.

	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно
	{
#define MAX(A, B) (((A) >= (B)) ? (A) : (B)) 
		int i = 10, j = 12, k;
		k = MAX(i, j);			//k = 12 , i = 10, j = 12
		k = MAX(j, i) * 2;		//k = 24, i = 10, j = 12
		k = MAX(j, i + 3);		//k = 13, i = 12, j = 12
		k = MAX(i--, j++);		//k = 13, i = 9,  j = 14 Постфиксный инкремент срабатывает дважды
		stop
	}

	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???

	{
#define EXCHANGE(X, Y) int T = 0; T=static_cast<int> (X); X=static_cast<int> (Y); Y=static_cast<int> (T); 
		int x1 = 1, y1 = -1;
		EXCHANGE(x1, y1);
		{
			int x2 = 100, y2 = -100;
			EXCHANGE(x2, y2);
			stop
		}
	}

	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?
	{
		int iNN;
#define NNN
		// #define MMM
#if defined NNN && defined MMM
		iNN = 0;
#elif defined MMM
		iNN = 1;
#elif defined NNN 
		iNN = 2;

#else
		iNN = -1;
#endif

		stop
	}



	//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
	//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.

	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros

	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration
	{
#if defined	_DEBUG 
		std::cout << "Debug";
#elif defined NDEBUG
		std::cout << "Release configuration!";
#endif
		int x;
		//std::cin >> x;
		std::cout << std::endl;
		std::cout << std::endl;

	}

	//Задание 2.5. Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, объявите и проинициализируйте переменную,
	//которая может становиться как однобайтовой, так и расширенной без 
	//изменения исходного текста.
	//С помощью отладчика проверьте результат.
	{
		//#define _UNICODE
#include <tchar.h>
		_TCHAR T = __T('A');




		stop

	}


	// ********************************************************
	//Задание 3.Заголовочные файлы. Директива #include
	//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h
	{
#if defined	_DEBUG 
#include "1.h"
#elif defined NDEBUG
#include "2.h"
#endif
		MyEnum D = My2;
		stop
	}
	// ********************************************************

	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"
	{
		int n = 10;
		char c = 'D';
		double d = 47;

		int *pn = &n;
		char *pc = &c;
		double *pd = &d;

		stop
	}
	//Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?
	{
		char *pc = "SDF";
		char c = 0;
		pc++;
		c = *pc;
		//		*pc = 'U';
		stop
	}


	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = { 1, 3 };  // неполная инициализация массива
		int* pn = &nAr[0];	// устанавливаем указатель на 0 элемент массива 
		(*pn)++; // Увеличиваем значение 0 элемента массива на 1	
		pn++;	// Переводим указатель на следующий элемент массива

		char cAr[] = { 'A', 'B', 'C', 'D' }; // Инициализируем массив из 4 элементов
		char* pc = &cAr[0]; // устанавливаем указатель на 0 элемент массива
		(*pc) = (*pc) + 5;	// Увеличиваем значение 0 элемента массива на 5 = F
		pc = pc + 3;	// Переводим указатель на 3 элемент массива

		double dAr[3] = { 1.0, 2.0 }; // неполная инициализация массива
		double* pd1 = &dAr[0]; // устанавливаем указатель на 0 элемент массива
		double* pd2 = pd1; // устанавливаем указатель на 0 элемент массива
		(*pd2) += 2; // Увеличиваем значение 0 элемента массива на 2
		pd2 += 2; // устанавливаем указатель pd2 на 2 элемент массива = 0.

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];
		pd2 = &dAr[1];
		int nNumber = pd2 - pd1; // Результат означает на сколько элементов в массиве один элемент стоит от другого элемента 

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.

		if (pd1 == pd2) { std::cout << "pd1 равен pd2"; }
		else if (pd1 < pd2) { std::cout << "pd1 меньше pd2"; }
		else if (pd1 > pd2) { std::cout << "pd1 больше pd2"; }
		else			 { std::cout << "pd1 и pd2 не являются указателями на объекты одного и того же массива /n или они разных типов"; };
		//std::cin >> nNumber;
		std::cout << std::endl;
		std::cout << std::endl;

		stop
	}


	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 
	//Следовательно, возникает необходимость явного преобразования
	//указателя. 
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display
	{
		unsigned int nObject5 = 0x55667788;
		unsigned int* pnObject5 = &nObject5;

		//Раскомментировав следующую строчку кода, обратите внимание
		//на сообщение компилятора - он не считает преобразование 
		//"легальным" (безопасным)
		unsigned char* pucObject5;
		//pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)
		pucObject5 = reinterpret_cast<unsigned char*>(pnObject5);	//а такое
		//преобразование - целиком на совести программиста.
		//Его можно применять, только четко представляя себе
		//результат преобразования (2)

		//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
		char cc = *(pucObject5++); // сс= 0x88 , p изменился на 1 байт, *p= 0x0047f5f5
		cc = (*pucObject5)++;// сс= 0x77 , p не менялся, *p= 0x0047f5f5

		cc = ++*(pucObject5); // сс= 0x79 , p не менялся, *p= 0x0047f5f5
		cc = *(++pucObject5); // сс= 0x66 , p изменился на 1 байт, *p= 0x0047f5f6
		stop
	}

	//Задание 7. Void-указатель. 
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	{
		void*	pVoid;	//объявление void-указателя
		int	nObject3 = 5;
		char cObject3 = 'A';
		int*	pInt = &nObject3;
		pVoid = &nObject3;
		pVoid = &cObject3;
		pVoid = pInt;

		//Прежде, чем раскомментировать следующую строчку, вспомните:
		//что нужно сделать, чтобы выражение стало корректным 	
		pInt = (int*)pVoid;

		//Что нужно сделать для того, чтобы следующее закомментированное выражение
		//стало корректным?
		{
			const int n = 1;
			const void *pVoid = &n;//????объявить слева void-указатель
		}



		//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
		//могут Вас ожидать при явном приведении типа void-указателя,
		//который в момент времени (1) указывает на double, к типу 
		//указателя на int (2) 

		double dObject3 = 33.33;
		pVoid = &dObject3;	//(1)

		int nTmp = *(static_cast<int*>(pVoid)); //(2) nTmp = 1889785610
		stop
	}
	//Задание 8. Модификатор const. В каждом из заданий
	//объявите указатель требуемого вида. Посредством каждого
	//указателя попробуйте:
	//получить значение по адресу
	//записать новое значение по адресу
	//модифицировать указатель

	//Задание 8a. Указатель является константой. 
	{
		int i = 0, t = 1;
		int *const pi = &i;
		t = *pi;
		*pi = 5;
		//pi++; нельзя модифицировать

		stop
	}

		//Задание 8б. Указываемое значение является константой.
		{
		int i = 0, t = 1;
		int const * pi = &i;
		t = *pi;
		//*pi = 5; нельзя модифицировать
		pi++;

		stop
	}


	//Задание 8в. И указатель, и указываемое значение
	//являются константами. 
		{
		int i = 0, t = 1;
		int const *const pi = &i;
		t = *pi;
		//*pi = 5; нельзя модифицировать
		//pi++; нельзя модифицировать

		stop
	}


	//Задание 8г. Указатель на переменную, объявленную с
	//ключевым словом const. 
		{
			const int nN = 1;
			const int * pn = &nN; //Объявите указатель и проинициализируйте его выражением - &nN	

			stop
		}


	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
		{
			int	n1 = 1;

			//Объявите указатель pn и проинициализируйте его так, чтобы он
			//"указывал" на n1
			int * pn = &n1;

			//Объявите указатель ppn и проинициализируйте его так, чтобы он
			//"указывал" на pn
			int ** ppn = &pn;

			//Объявите указатель pppn и проинициализируйте его так, чтобы он
			//"указывал" на ppn
			int *** pppn = &ppn;

			//С помощью указателей pn, ppn и ppn получите значение объекта n1
			//и присвойте его n2

			int n2 = 7;

			*pn = n2;
			**ppn = n2;
			***pppn = n2;


				stop
		}



	return 0;
}//end main
