
/*************************************************************
	Практическое занятие №5. 
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции
	Структуры
*************************************************************/
#include <tchar.h>
#include <iostream>
#include <cstdio>
#include "other.h"
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <string>
#include "Book.h"


#define	  stop __asm nop

int _tmain()
{
	setlocale(LC_ALL, "Russian");
	//Тема "Старые" потоковые функции стандартной библиотеки
	//Задание 1. С помощью функции scanf сформирйуте три коэффициента: A,B,C
	{
		printf("Задание 1. Функция квадратного уравнения\n\n");
		double A = 0, B = 0, C = 0, x, y;
		printf("Введите через пробел коэффициенты A, B, C:\n");
		scanf("%lf %lf %lf", &A, &B, &C);

		//Задание 2. Выведите (красиво!) таблицу значений y=A*x*x + B*x + C
		//при изменении x в диапазоне -2 до +2 с шагом 0.5
		printf("Печатаем  таблицу значений y=%g*x*x + %g*x + %g \nпри изменении x в диапазоне -2 до +2 с шагом 0.5:\n\n",A, B, C);
		for (x = -2; x <= 2; x = x + 0.5)
		{
			printf("|y=%-5.3g|x=%-5.3g|\n", y = A*x*x + B*x + C, x);
		}
		printf("\n\n");
		system("pause");
	}
	///////////////////////////////////////////////////////////////////
	//Тема Указатели на функции

	//Задание 1. Указатель на функцию. "Калькулятор".
	//Напишите функции:
	//1)Sum - принимает два значения double и возвращает сумму
	//этих значений
	//2)Sub- принимает два значения double и возвращает разность
	//этих значений
	//3)Mul - *
	//4)Div - /
	//5)а для возведения в степень можете использовать функцию стандартной библиотеки
	//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
	//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
	//		вариантов этой функции, а Вам потребуется сформировать указатель на 
	//		double pow(double, double);

	//Предоставьте пользователю	следующую возможность:
	//пока пользователь хочет пользоваться услугами Вашего калькулятора,
	//он может вводить два значения и знак операции
	//а Вы выводите результат. Результат получаете посредством вызова
	//соответствующей Вашей функции по указателю.
	//Предусмотрите возможность ввода непредусмотренного знака операции

	{
		double a, b, res;
		typedef double(*pfunc)(double, double);
		pfunc fop[] = { Sum, Sub, Mul, Div, pow };
		const char op[] = { '+', '-', '*', '/', 'p' };
		size_t n, t;
		n = sizeof(op) / sizeof(op[0]);
		printf("\n\nЗадание 1. Калькулятор\n\n");
		if (n != (sizeof(fop) / sizeof(fop[0])))
		{
		printf("Внимание! Количество функций не соответствует количесву обозначений операций для них\n\n");
		}
		printf("Введите через пробел два числа и значение операции латинскими буквами \nиз этого списка:");
		for (size_t i = 0; i < n; i++) {	printf(" %c", op[i]);	}
		printf("\nПример: 4.3 5.7 +\n\n");
		while (true)
		{
		char c;
		t = n;
		scanf("%lf %lf %c", &a, &b, &c);
		fflush(stdin);
		for (size_t i = 0; i < n; i++) { if (c == op[i]) { t = i; } }
		if (t == n) { printf("\n\nТакое значение операции отсутсвует в списке! Введите данные снова: \n\n"); }
		else{ break; }
		}
		res = Calc(a, b, fop[t]);
		printf("\n\nРезультат = %g\n\n", res);
		system("pause");
		stop
		}

	//Задание 2. Указатель на функцию в качестве аргумента.
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//2a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй

	{
		printf("\n\nЗадание 2а. Функция перестановки и сортировки двух целых значений \nSwapInt и CmpInt\n\n");
		const int N = 20;
		int nAr[N] = { 0 };	//массив для сортировки
		srand(static_cast<unsigned int>(time(0)));
		//Печать исходного массива
		printf("Начальный массив из %d элементов:\n\n", N);
		for (size_t i = 0; i < N; i++)
		{
			nAr[i] = rand() % 100 + 1;
			std::cout << nAr[i] << " ";
		}
		
		//Вызов сортировки
		int nTotal = sizeof(nAr) / sizeof(nAr[0]);			//количество элементов в массиве 
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

		//Печать результатов сортировки
		printf("\n\nМассив из %d элементов после сортировки:\n\n", N);
		for (size_t i = 0; i < N; i++)
		{
			std::cout << nAr[i] << " ";
		}
		printf("\n\n");
		system("pause");
		stop
	}

	//Задание 2б. По аналогии с 8а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
	{
		printf("\n\nЗадание 2б. Функция перестановки и сортировки двух значений Double\nSwapDouble и CmpDouble\n\n");
		const int N = 20;
		double nAr[N] = { 0 };	//массив для сортировки
		srand(static_cast<unsigned int>(time(0)));
		//Печать исходного массива
		printf("Начальный массив из %d элементов:\n\n", N);
		for (size_t i = 0; i < N; i++)
		{
			nAr[i] = static_cast<double>(rand() % 10000)/100 + 1;
			std::cout << nAr[i] << " ";
		}

		//Вызов сортировки
		int nTotal = sizeof(nAr) / sizeof(nAr[0]);			//количество элементов в массиве 
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(double), SwapDouble, CmpDouble);

		//Печать результатов сортировки
		printf("\n\nМассив из %d элементов после сортировки:\n\n", N);
		for (size_t i = 0; i < N; i++)
		{
			std::cout << nAr[i] << " ";
		}
		printf("\n\n");
		system("pause");
		stop
	}

	//Задание 2в*. По аналогии с 8а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort 
	//для сортировки массива указателей на строки.
	
	{
		printf("\n\nЗадание 2в. Функция перестановки и сортировки двух значений char []:\nSwapStr и CmpStr\n\n");
		char s[] = "QWERTY";
		char* arStr[] = { "WWW", "SDF", "ABC", s, "123345", "ABC", "1234F" };
		int nTotal = sizeof(arStr)/sizeof(char*);			//количество элементов в массиве 
		
		
		//Печать исходного массива
		printf("Начальный массив из %d элементов:\n\n", nTotal);
		for (size_t i = 0; i < nTotal; i++)
		{
			std::cout << arStr[i] << std::endl;
		}

		//Вызов сортировки
		
		Sort(reinterpret_cast<char*>(&arStr[0]), nTotal, sizeof(char*), SwapStr, CmpStr);

		//Печать результатов сортировки
		printf("\n\nМассив из %d элементов после сортировки:\n\n", nTotal);
		for (size_t i = 0; i < nTotal; i++)
		{
			std::cout << arStr[i] << std::endl;
		}
		printf("\n\n");
		system("pause");
		stop
	}

	

	//Задание 3. Массивы указателей на функцию.
	//Напишите несколько функций вида
	//const char* GetString1();
	//const char* GetString2();
	//		...., каждая из функций возвращает указатель на свою строку
	//(подумайте - какой адрес Вы имеете право возвращать из функции)
	

	//Объявите и проинициализируйте массив указателей на функции
	//GetString1,GetString2...
	{
		printf("\n\nЗадание 3. Массивы указателей на функцию\n\n");
		typedef const char* (*StrF)(void);
		StrF pStrF[] = { GetString1, GetString2, GetString3, GetString4, GetString5 };

		//Введите номер функции, которую Вы хотите вызвать:
		int n;
		printf("Введите номер функции от 1 до %d включительно:\n\n", (sizeof(pStrF) / sizeof(pStrF[0])));
		while (true)
		{
			scanf_s("%d", &n);
			fflush(stdin);
			if ((n<1) || (n>(sizeof(pStrF) / sizeof(pStrF[0]))))
			{
				printf("\n\nВы ввели неверное значение! Повторите ввод:\n\n");
			}
			else { break; }
		}

		//Вызовите функцию 
		const char* p = String_n(pStrF[n - 1]);
		
		//Распечатайте результат
		printf("\n\nРезультат выбранной функции:\nСтрока %s\n\n", p);
		system("pause");
		stop
	}

//////////////////////////////////////////////////////////////////////////////////////

	//Тема. Структуры С.	
	//Задание 1. Объявите структуру BOOK, описывающую книгу
	//(автор, заглавие, год издания, цена, категория…).
	//Подумайте: какого типа могут быть поля структуры.
	//Подсказка: объявление структуры рекомендуется выносить
	//в заголовочный файл.
	printf("\n\nТема. Структуры С.\n\n");



	//Задание 2. Создайте разными способами (глобальный, локальный, статический,
	//динамический) экземпляры (объекты) типа BOOK (без инициализации).
	//Определите - сколько памяти отводит компилятор под каждый
	//такой объект. Как инициализируются (или не инициализируются) поля
	//структуры. Подумайте: от чего зависит объем выделяемой памяти?
	
	book b1;
	int n = sizeof(b1);
	static book b5;
	n = sizeof(b5);
	{
		book b2;
		n = sizeof(b2);
		static book b3;
		n = sizeof(b3);
	}

	struct book * pb4 = new book;
	n = sizeof(*pb4);
	delete pb4;
	stop

		//все значения поля структуры являются локальными и не инициализируются нулями.
		// Статические структуры не определяются вообще
		// Размер структуры зависит от суммы размера всех полей и их совместного расположения.
		//Для уменьшения размеры структуры, сначала следует располагать поля с наибольшим размером и потом по убыванию.
		//При этом учитывать кратность размера полей.

		//Задание 3. Заполните поля созданных объектов.
		//Замечание: если для хранения строки используется массив, необходимо
		//предусмотреть "защиту" от выхода за границы массива.
		strcpy(b1.name, "NNNNNNNNNN");
		strcpy(b1.author, "AAAAAAAAAA");
		strcpy(b1.categ, "CCCCCCCCCC");
		b1.year = 2015;
		b1.price = 4000.50;
		b1.pages = 7000;

		strcpy(b5.name, "1111111111");
		strcpy(b5.author, "2222222222");
		strcpy(b5.categ, "3333333333");
		b5.year = 2015;
		b5.price = 4000.50;
		b5.pages = 7000;
		
		
		stop

			//Задание 4. Напишите функцию, выводящую на экран реквизиты книги.
			//Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
			//Для вывода на консоль используйте функцию стандартной библиотеки
			//printf
		printf("\n\nПечать книг на экране:\n\n");
		title();
		display(b1, 1);
		display(b5, 2);
		printf("\n\n\n");
		system("pause");



	//Задание 5. Напишите функцию для формирования полей структуры.
	//Для ввода используйте функцию стандартной библиотеки scanf
	//Замечание: неплохо заложить в такую функцию возможность проверки
	//корректности введенного значения, например, год издания не может быть
	//меьше, чем... (год появления письменности), категорию ползователь
	//должен выбирать из существующих, цена не может быть отрицательной...

		printf("Книга b1\n");
		filling(b1);
		printf("\n\nКнига b5\n");
		filling(b5);
		title();
		display(b1, 1);
		display(b5, 2);
		printf("\n\n\n");
		system("pause");

	return 0;
}//main

