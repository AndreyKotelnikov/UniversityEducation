/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/


#define	  stop __asm nop
#include <ctime>
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <string>
#include<Windows.h>
int nref = 1;
int& ref = nref;


int main()
{

	///////////////////////////////////////////////////////////////
	//			Встроенные массивы                               //
	///////////////////////////////////////////////////////////////

	//Задание 1. Объявите трехмерный массив и сформируйте указанные
	//значения элементов следующим образом:
	//а) проинициализируйте массив при объявлении
	{
		int ar[][2][3] = { { { 1, 2, 3 }, { 4, 5, 6 } },
		{ { 7, 8, 9 }, { 10, 11, 12 } } };

		stop

			//б) объявите неинициализированный массив и присвойте значения элементам
			//	с помощью кода
			//					 |--------|		
			//				   / |3  3  3 |		
			//    			 |---------|3 |
			//			   / | 2  2  2 |3 |
			//			  |---------|2 |__|
			//			  | 1  1  1 |2 | /
			//			  | 1  1  1 |__| 
			//			  | 1  1  1 | /
			//			  |_________|
			//Средствами отладчика проверьте правильность Вашего решения.
			const int N = 3, M = 3, K = 3;
		int ar1[N][M][K];
		int* par1 = &ar1[0][0][0];
		unsigned int s = (sizeof(ar1) / sizeof(ar1[0][0][0]));
		for (unsigned int i = 0; i < s; i++)
		{
		/*	(i < (M*K)) ? (*par1 = 1) : ((i >= (((M*K) * 2))) ? (*par1 = 3) : (*par1 = 2));*/
			par1[i] = i / (M*K)+1;
			

		}
		stop


			//в) найдите сумму элементов массива
			int SUM = 0;
		par1 = &ar1[0][0][0];
		for (unsigned int i = 0; i < s; i++)
		{
			SUM += *par1;
			par1++;

		}
		stop

			//г) проинициализируйте массив при объявлении:
			//					 |--------|		
			//				   / |3  0  0 |		
			//    			 |---------|0 |
			//			   / | 2  0  0 |0 |
			//			  |---------|0 |__|
			//			  | 1  0  0 |0 | /
			//			  | 0  0  0 |__| 
			//			  | 0  0  0 | /
			//			  |_________|

			int ar2[N][M][K] = { { 1 }, { 2 }, { 3 } };
	}
	//д) Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.

	const int N = 5, M = 50;
	char str[N][M] = { "yutriooe", { "uitriuty" }, { "lkdfjglir" } };
	const char* str1[] = { "yutriooe", { "uitriuty" }, { "lkdfjglir" } };
	str[1][0] = 'V';
	//str1[2][3] = 'y';

	stop



		///////////////////////////////////////////////////////////////
		//			Динамическое выделение памяти                    //
		///////////////////////////////////////////////////////////////
		//Задание2. Создайте динамический двухмерный массив с размерностями,
		//вычисляемыми в процессе выполнения программы - N*M.
		//Задайте значения элементов помощью генератора случайных чисел.
		//Найдите  сумму элементов.
		//Подсказка 1: для генерации случайных чисел используйте функцию
		//стандартной библиотеки - rand() (<cstdlib>)
		//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
		//чисел являются «псевдослучайными», то есть при двух последовательных запусках
		//приложения Вы получаете две одинаковые последовательности значений.
		//Для того чтобы генерируемые "случайные" значения были разными при каждом 
		//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
		//и time() (<ctime>).
		//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
		//Функция time() задает эту точку отсчета, считывая текущее время

		//srand( time( 0 ) );

	//{

	//	setlocale(LC_ALL, "Russian");
	//	size_t N, M;
	//	N = 5;
	//	M = 10;
	//	int *p = nullptr;
	//	p = new int[N*M];
	//	int **pp = new int*[N];
	//	for (size_t i = 0; i < N; i++)
	//	{
	//		pp[i] = p + i*M;
	//	}
	//	int s = 0;
	//	srand(static_cast<unsigned int>(time(0)));
	//	for (size_t i = 0; i < N*M; i++)
	//	{
	//		p[i] = rand()%10;
	//		std::cout << p[i] << " ";
	//		s += p[i];
	//		if (((i+1) % M) == 0) { printf("\nСумма по строке: %d\n\n", s); s = 0; }
	//	}
	//	
	//	std::cin >> s;
	//	std::cout << std::endl;


	////Задание2а. В сформированном массиве отсортируйте каждую строку по
	////убыванию значений. Используйте сортировку "выбором"
	//	
	//	int tmp = 0;
	//	for (size_t n = 0; n < N; n++)
	//	{
	//		for (int i = 0; i < M; i++) // i - номер текущего шага
	//		{
	//			int pos = i;
	//			tmp = pp[n][i];
	//			for (int j = i + 1; j < M; j++) // цикл выбора наименьшего элемента
	//			{
	//				if (pp[n][j] < tmp)
	//				{
	//					pos = j;
	//					tmp = pp[n][j];
	//				}
	//			}
	//			pp[n][pos] = pp[n][i];
	//			pp[n][i] = tmp; // меняем местами наименьший с pp[n][i]
	//		}
	//	}
	//	printf("\n\n");
	//	for (size_t i = 0; i < N*M; i++)
	//	{
	//		
	//		std::cout << p[i] << " ";
	//		if (((i + 1) % M) == 0) { printf("\n\n"); }
	//	}
	//	std::cin >> s;
	//	std::cout << std::endl;
	//	


	////Задание2б. Объявите одномерный массив размерностью N.
	////Сформируйте значение i-ого элемента одномерного массива  
	////равным среднему значению элементов i-ой строки
	////двухмерного массива

	//	double* pn = new double[N];
	//	double s1 = 0;
	//	for (size_t i = 0; i < N; i++)
	//	{
	//		for (size_t j = 0; j < M; j++)
	//		{
	//			s1 += pp[i][j];
	//		}
	//		pn[i] = s1 / M;
	//		s1 = 0;
	//		printf("%g \n", pn[i]);
	//	}
	//	std::cin >> s1;
	//	std::cout << std::endl;
	//delete[] p;
	//delete[] pn;
	//p = nullptr;
	//pn = nullptr;
	//}
	//Подсказка - не забудьте освободить память!




	
	/////////////////////////////////////////////////////////////////////
	//Задание 3. а) Напишите фрагмент кода, который вводит NN целых чисел с помощью
	//потока ввода в объявленный Вами встроенный одномерный массив, каждый раз
	//упорядочивая полученное значение по возрастанию
	
	//{
	//	const size_t N = 10;
	//	int ar[N] = { 0 };
	//	int tmp = 0;
	//	printf("Введите %d целых чисел в массив: \n", N);
	//	for (size_t i = 0; i < N; i++)
	//	{
	//		std::cin >> ar[i];
	//		for (size_t j = i; j >= 1; j--)
	//		{
	//			if (ar[j] < ar[j-1])
	//			{
	//				tmp = ar[j];
	//				ar[j] = ar[j - 1];
	//				ar[j - 1] = tmp;
	//			}
	//		}
	//	}
	//	std::cout << std::endl;
	//	for (size_t i = 0; i < N; i++)
	//	{
	//		std::cout << ar[i] << std::endl;
	//	}
	//	std::cin >> tmp;
	//	std::cout << std::endl;
	//}

	////б) Простой поиск.
	////Модифицируйте предыдущее задание следующим образом:очередное значение
	////вводится в массив только при условии, что там еще такого нет (то есть 
	////дубли игнорируются
	//{
	//	const size_t N = 10;
	//	int ar[N] = { 0 };
	//	int tmp = 0;
	//	printf("Введите %d целых чисел в массив: \n", N);
	//	while (tmp < N)
	//{
	//std::cin >> ar[tmp];
	//for (size_t j = tmp; j >= 1; j--)
	//{
	//if (ar[tmp] == ar[j - 1])
	//{
	//printf("Вводимое значение уже содержится в элементе массива ar[%d],\n введите новое значение в элемент ar[%d] \n", j - 1, tmp);
	//tmp--;
	//break;
	//}
	//}
	//tmp++;
	//}

	//	for (size_t i = 0; i < N; i++)
	//	{
	//		for (size_t j = i; j >= 1; j--)
	//		{
	//			if (ar[j] < ar[j - 1])
	//			{
	//				tmp = ar[j];
	//				ar[j] = ar[j - 1];
	//				ar[j - 1] = tmp;
	//			}
	//		}
	//	}
	//		std::cout << std::endl;
	//	for (size_t i = 0; i < N; i++)
	//	{
	//	std::cout << ar[i] << std::endl;
	//	}
	//	std::cin >> tmp;
	//	std::cout << std::endl;
	//}



	///////////////////////////////////////////////////////////////////////////
	//Задание 4.С помощью данной заготовки напишите программу,
	//которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный встроенный массив 5*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение массива (больше свободных строк нет);
	//сортировка строк в алфавитном порядке. Пояснение: крайне
	//не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти. Намного эффективнее завести массив
	//указателей на соответствующие строки и перемещать только
	//указатели.

	//Подсказка: для лексиграфического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.


	//Определите необходимые значения как константы
	//STOP_STRING  -  "*"	//признак "прекратить ввод"
	//M  -  80	//максимальный размер одной строки
	//N  -  10	//максимальное количество строк в массиве
	
	

//	{
//		#define STOP_STRING "*"
//		const size_t N = 10, M = 80;
//		size_t s = 0;
//		setlocale(LC_ALL, "Russian");
//
//		//Объявите двухмерный массив с именем cBuffer типа char и
//		// размерностью N*M
//		char cBuffer[N][M];
//
//		//Объявите массив (с именем cPointers) указателей на строки
//		//размерностью N
//		 char *cPointers[N];
//
//		//Цикл ввода строк:
//		//а) выведите приглашение для ввода
//		std::cout << "Введите строки массива латинскими буквами,\n";
//		//б) пока не введена строка STOP_STRING или не заполнен весь массив
//		printf("пока не введена строка %s или не заполнен весь массив:\n", STOP_STRING);
//			for (size_t i = 0; i < N; i++)
//			{
//				std::cin >> cBuffer[i]; //ввод строки в массив cBuffer:
//				if (strcmp(cBuffer[i], STOP_STRING) == 0)
//				{
//					s = i;
//					break;
//				}	//если введена строка - признак окончания, то выйти из цикла
//			}
//			for (size_t nIndex = 0; nIndex < s; nIndex++)
//			{
//				cPointers[nIndex] = cBuffer[nIndex];
//			}//Присвойте элементу массива cPointers с индексом nIndex
//			//указатель на строку с номером nIndex в массиве cBuffer
//
//		//Выдать диагностику о том, что прием строк завершен.
//		std::cout << "Приём строк завершён, приступаем к пузырькам:\n\n";
//		if (s == 0)	{ std::cout << "Пузырьков не получится, вы не ввели строки\n"; }
//
//		//Теперь сортируем строки:
//		//const char *tmp;
//
//		for (int i = 1; i < s; i++)
//		{
//			std::cout << std::endl;
//			printf("Печатаем строки %d итерации: \n", i);
//			for (int j = 0; j < s; j++)
//			{
//				if (strcmp(cPointers[i], cPointers[j]) < 0)
//				{
//					char *tmp = cPointers[i];
//					cPointers[i] = cPointers[j];
//					cPointers[j] = tmp;
//				}
//				std::cout << cPointers[j] << std::endl;
//			}
//		}
//		std::cin >> s;
//		std::cout << std::endl;
//
//		//Цикл сортировки строк по методу "всплывающего пузырька" в
//		//порядке возрастания. На каждой итерации - промежуточная печать 
//		//отсортированных строк
//
//	}
//
//
//	//Задание 5. Реализуйте задание №4, используя не встроенные,
//	//а динамические массивы (массив?). Так как строки могут быть разной длины,
//	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
//	//сколько требуется для ее хранения.
//	//При этом необходимые параметры (количество строк
//	// сформируйте с помощью потока ввода
//
//
//{
//	#define STOP_STRING "*"
//	size_t nStringNumber;
//	const size_t M = 80;
//	setlocale(LC_ALL, "Russian");
//
//	std::cout << "Введите количество строк:\n";
//	std::cin >> nStringNumber;
//	size_t s = nStringNumber;
//	char **cPointers = new char*[nStringNumber];
//	{
//		char str[M];
//		//Цикл ввода строк:
//		for (size_t j, i = 0; i < nStringNumber; i++)
//		{
//			j = 0;
//			std::cout << std::endl;
//			printf("Введите %d строку массива латинскими буквами длинной до %d символов,\nили введите %s для окончания ввода строк:\n", i+1, M, STOP_STRING);
//			std::cin >> str; //ввод строки в массив cBuffer:
//			if (strcmp(str, STOP_STRING) == 0)
//			{
//				s = i;
//				break;
//			}	//если введена строка - признак окончания, то выйти из цикла
//
//			/*while (str[j])
//			{
//				j++;
//			}*/
//			cPointers[i] = new char[strlen(str) + 1];
//			/*memcpy(cPointers[i], str, j + 1);*/
//			strcpy(cPointers[i], str);
//			}
//	}
//	
//	
//	//Выдать диагностику о том, что прием строк завершен.
//	std::cout << std::endl;
//	std::cout << "Приём строк завершён, приступаем к пузырькам:\n";
//	if (s == 0)	{ std::cout << "Пузырьков не получится, вы не ввели строки\n"; }
//
//	//Цикл сортировки строк методом "всплывающего пузырька" в
//	//порядке возрастания кода первого символа
//	char *tmp;
//
//	for (int i = 1; i < s; i++)
//	{
//		std::cout << std::endl;
//		printf("Печатаем строки %d итерации: \n", i);
//		for (int j = 0; j < s; j++)
//		{
//			if (strcmp(cPointers[i], cPointers[j]) < 0)
//			{
//				tmp = cPointers[i];
//				cPointers[i] = cPointers[j];
//				cPointers[j] = tmp;
//			}
//			std::cout << cPointers[j] << std::endl;
//		}
//	}
//	
//	//Освобождение занятой памяти:
//	for (size_t i = 0; i < s; i++)
//	{
//		delete[] cPointers[i];
//		cPointers[i] = nullptr;
//	}
//	delete[] cPointers;
//	cPointers = nullptr;	
//	std::cin >> s;
//	std::cout << std::endl;
//}
	


	//Задание 6. Объявление и использование указателей на многомерные
	// массивы. Проинициализируйте трехмерный массив
	//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
	//кода, который меняет местами значения элементов четных
	//и нечетных слоев:
	//	было:			     |--------|		
	//  				   / |4  4  4 |		
	//					 |--------|	4 |	
	//				   / |3  3  3 |	4 |	
	//    			 |---------|3 |   |
    //			   / | 2  2  2 |3 | /
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|

	//	стало:			     |--------|		
	//  				   / |3  3  3 |		
	//					 |--------|	3 |	
	//				   / |4  4  4 |	3 |	
	//    			 |---------|4 |   |
    //			   / | 1  1  1 |4 | /
	//			  |---------|1 |__|
	//			  | 2  2  2 |1 | /
	//			  | 2  2  2 |__| 
	//			  | 2  2  2 | /
	//			  |_________|

	{
		const int N = 4, M = 3, K = 3;
		double dArray[N][M][K] = { {1,1,1,1,1,1,1,1,1},{2,2,2,2,2,2,2,2,2},{3,3,3,3,3,3,3,3,3},{4,4,4,4,4,4,4,4,4} };
	//	double  (*p1)[3][3], (*p2)[3][3];
		
		
		for (int i = 0; i < N-1; i=i+2)
		{
			//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
			double(*p1)[K] = dArray[i];
			double(*p2)[K] = dArray[i + 1];
			//переставляем местами элементы i-того и i+1-ого слоев
			for (size_t j = 0; j < M*K; j++)
			{
				double tmp = (*p1)[j];
				(*p1)[j] = (*p2)[j];
				(*p2)[j] = tmp;

			}
			
		}
		stop
	}

	///////////////////////////////////////////////////////////////////////////
	//Задание 7а. Объявите двухмерный встроенный массив элементов типа char.
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*' и '_'  
setlocale(LC_ALL, "Russian");
	{
		const size_t N = 5, M = 20;
		char ar[N][M];
		srand(static_cast<unsigned int>(time(0)));
		std::cout << "Заполняем массив случайными символами:";
		std::cout << std::endl;
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				ar[i][j] = ((rand() % 2 == 0) ? '*' : '_');
				std::cout << ar[i][j];
			}
			std::cout << std::endl;
		}
		
		std::cout << std::endl;

		//В каждой строке "сдвиньте звездочки" в начало строки, например:
		//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
		//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
		//и распечатайте массив по строкам - "постройте распределение"
		//std::cout << "Сдвигаем звёздочки в начало строки:";
		std::cout << std::endl;
		char tmp;
		size_t k = 1, z = 0, f = 0;
		for (size_t i = 0; i < N; i++)
		{
			while (k == 1)
			{
				f = 0;
				k = 0;
				for (size_t j = 0; j < M; j++)
				{
					if ((ar[i][j] != '*') && (f == 0)) { z = j; f = 1; }
					else
					{
						if ((ar[i][j] == '*') && (z<j))	
						{ 
							tmp = ar[i][z];
							ar[i][z] = ar[i][j];
							ar[i][j] = tmp;
							f = 0;
							k = 1;
						}
					}
				}
			}
			for (size_t  k = 0;  k < M; k++)
			{
				std::cout << ar[i][k];
			}
			k = 1;
			std::cout << std::endl;
		}
		std::cin >> ar[0][0];
		std::cout << std::endl;



	}
	// 7б. Модифицируйте предыдущее задание следующим способом:
	//После заполнения массива с помощью генератора случайных чисел
	//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
	//"распределение"

	{
		const size_t N = 5, M = 20;
		char ar[N][M];
		srand(static_cast<unsigned int>(time(0)));
		std::cout << "Заполняем массив случайными символами:";
		std::cout << std::endl;
		for (size_t i = 0; i < N; i++)
		{
			for (size_t j = 0; j < M; j++)
			{
				ar[i][j] = ((rand() % 2 == 0) ? '*' : '_');
				std::cout << ar[i][j];
			}
			std::cout << std::endl;
		}

		std::cout << std::endl;

		//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
		//"распределение"
		std::cout << "Сдвигаем звёздочки по столбцам вниз:";
		std::cout << std::endl;
		char tmp;
		size_t k = 1, z = 0, f = 0;
		for (size_t i = 0; i < M; i++)
		{
			while (k == 1)
			{
				f = 0;
				k = 0;
				for (size_t j = 0; j < N; j++)
				{
					if ((ar[j][i] != '*') && (f == 0)) { z = j; f = 1; }
					else
					{
						if ((ar[j][i] == '*') && (z<j))
						{
							tmp = ar[z][i];
							ar[z][i] = ar[j][i];
							ar[j][i] = tmp;
							f = 0;
							k = 1;
						}
					}
				}
			}
			
			k = 1;
			
		}
		for (size_t i = N; i > 0; i--)
		{
			for (size_t k = 0; k < M; k++)
			{
				std::cout << ar[i-1][k];
			}
			std::cout << std::endl;
		}
		std::cin >> ar[0][0];
		std::cout << std::endl;



	}



	return 0;
}